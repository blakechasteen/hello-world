<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mythRL - Data Insight Revelation</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #fafafa;
            color: #333;
            line-height: 1.4;
            padding: 20px;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2em;
            font-weight: 300;
            margin-bottom: 5px;
            letter-spacing: -0.5px;
        }

        .subtitle {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 30px;
            font-weight: 300;
        }

        /* Compact bullet graph grid */
        .bullet-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 8px;
            margin: 30px 0;
        }

        .bullet-item {
            display: flex;
            align-items: center;
            padding: 6px;
            background: white;
            border: 1px solid #e0e0e0;
            transition: all 0.3s ease;
        }

        .bullet-item:hover {
            border-color: #3498db;
            box-shadow: 0 2px 8px rgba(52, 152, 219, 0.2);
        }

        .bullet-label {
            width: 120px;
            font-size: 0.75em;
            color: #555;
            padding-right: 8px;
        }

        .bullet-viz {
            flex: 1;
            height: 24px;
            position: relative;
        }

        .bullet-value {
            width: 50px;
            text-align: right;
            font-size: 0.85em;
            font-weight: 600;
            color: #333;
        }

        /* Dense small multiples */
        .small-multiple-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
            margin: 30px 0;
        }

        .small-multiple {
            background: white;
            border: 1px solid #e0e0e0;
            padding: 10px;
            transition: all 0.3s ease;
        }

        .small-multiple:hover {
            border-color: #2ecc71;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(46, 204, 113, 0.15);
        }

        .sm-title {
            font-size: 0.7em;
            color: #666;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .sm-value {
            font-size: 1.4em;
            font-weight: 300;
            margin-bottom: 8px;
        }

        .sm-chart {
            height: 60px;
        }

        .sm-change {
            font-size: 0.7em;
            font-weight: 600;
            margin-top: 5px;
        }

        /* Animated sparklines */
        .sparkline-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 6px;
            margin: 30px 0;
        }

        .sparkline-row {
            display: flex;
            align-items: center;
            padding: 8px;
            background: white;
            border: 1px solid #e0e0e0;
            transition: all 0.3s ease;
        }

        .sparkline-row:hover {
            background: #f8f9fa;
            border-color: #e74c3c;
        }

        .spark-label {
            width: 100px;
            font-size: 0.75em;
            color: #555;
        }

        .spark-chart {
            flex: 1;
            height: 30px;
            margin: 0 10px;
        }

        .spark-value {
            width: 60px;
            text-align: right;
            font-size: 0.9em;
            font-weight: 600;
        }

        .spark-delta {
            width: 50px;
            text-align: right;
            font-size: 0.75em;
            font-weight: 600;
            margin-left: 8px;
        }

        /* Color-coded performance indicators */
        .color-excellent { color: #27ae60; }
        .color-good { color: #2ecc71; }
        .color-fair { color: #f39c12; }
        .color-poor { color: #e74c3c; }
        .color-critical { color: #c0392b; }

        .bg-excellent { background: #27ae60; }
        .bg-good { background: #2ecc71; }
        .bg-fair { background: #f39c12; }
        .bg-poor { background: #e74c3c; }
        .bg-critical { background: #c0392b; }

        /* Insight revelation animations */
        @keyframes reveal {
            from { 
                opacity: 0; 
                transform: translateY(10px);
            }
            to { 
                opacity: 1; 
                transform: translateY(0);
            }
        }

        @keyframes grow {
            from { transform: scaleX(0); }
            to { transform: scaleX(1); }
        }

        @keyframes pulse-highlight {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        .animated-enter {
            animation: reveal 0.6s ease-out forwards;
        }

        .animated-grow {
            animation: grow 1s ease-out forwards;
            transform-origin: left;
        }

        /* Heatmap matrix */
        .heatmap-container {
            margin: 30px 0;
            overflow-x: auto;
        }

        .heatmap-cell {
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .heatmap-cell:hover {
            stroke: #333;
            stroke-width: 2;
            opacity: 1 !important;
        }

        /* Mini histogram bars */
        .histogram-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 30px 0;
        }

        .histogram-item {
            background: white;
            border: 1px solid #e0e0e0;
            padding: 10px;
        }

        .histogram-title {
            font-size: 0.75em;
            color: #666;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .histogram-bars {
            display: flex;
            align-items: flex-end;
            height: 50px;
            gap: 2px;
        }

        .histogram-bar {
            flex: 1;
            background: #3498db;
            transition: all 0.3s ease;
            cursor: pointer;
            min-width: 4px;
        }

        .histogram-bar:hover {
            background: #e74c3c;
            transform: scaleY(1.1);
        }

        /* Compact table with inline viz */
        .dense-table {
            width: 100%;
            border-collapse: collapse;
            margin: 30px 0;
            background: white;
            font-size: 0.8em;
            border: 1px solid #e0e0e0;
        }

        .dense-table th {
            text-align: left;
            font-weight: 600;
            padding: 8px 6px;
            border-bottom: 2px solid #333;
            font-size: 0.75em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #555;
            background: #f8f9fa;
        }

        .dense-table td {
            padding: 6px;
            border-bottom: 1px solid #e0e0e0;
        }

        .dense-table tr:hover {
            background: #f8f9fa;
        }

        .inline-bar {
            display: inline-block;
            height: 12px;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            margin-left: 5px;
            vertical-align: middle;
            border-radius: 2px;
            transition: all 0.3s ease;
        }

        .inline-bar:hover {
            transform: scaleX(1.05);
        }

        .inline-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin: 0 2px;
            vertical-align: middle;
        }

        /* Trend indicators */
        .trend-up::after {
            content: 'â†—';
            color: #27ae60;
            margin-left: 4px;
            font-weight: bold;
        }

        .trend-down::after {
            content: 'â†˜';
            color: #e74c3c;
            margin-left: 4px;
            font-weight: bold;
        }

        .trend-flat::after {
            content: 'â†’';
            color: #95a5a6;
            margin-left: 4px;
        }

        /* Section headers */
        h2 {
            font-size: 1.3em;
            font-weight: 400;
            margin: 40px 0 15px 0;
            letter-spacing: -0.3px;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }

        .section-stats {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            font-size: 0.8em;
            color: #666;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .stat-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 3px;
            font-weight: 600;
            font-size: 0.9em;
        }

        /* Animated gradient backgrounds for emphasis */
        @keyframes gradient-shift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .gradient-bg {
            background: linear-gradient(270deg, #3498db, #2ecc71, #e74c3c);
            background-size: 400% 400%;
            animation: gradient-shift 15s ease infinite;
        }

        /* Distribution curves */
        .distribution-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 10px;
            margin: 30px 0;
        }

        .distribution-item {
            background: white;
            border: 1px solid #e0e0e0;
            padding: 12px;
        }

        .dist-title {
            font-size: 0.75em;
            color: #666;
            margin-bottom: 8px;
        }

        .dist-chart {
            height: 80px;
        }

        .dist-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 0.7em;
            color: #999;
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            font-size: 0.75em;
            pointer-events: none;
            z-index: 1000;
            border-radius: 3px;
            display: none;
        }

        /* Comparison bars */
        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 10px;
            margin: 30px 0;
        }

        .comparison-item {
            background: white;
            border: 1px solid #e0e0e0;
            padding: 12px;
        }

        .comparison-label {
            font-size: 0.75em;
            color: #666;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
        }

        .comparison-bars {
            display: flex;
            gap: 2px;
            height: 30px;
            align-items: flex-end;
        }

        .comparison-bar {
            flex: 1;
            transition: all 0.5s ease;
            cursor: pointer;
            position: relative;
        }

        .comparison-bar:hover {
            opacity: 0.7;
            transform: translateY(-2px);
        }

        .comparison-value {
            position: absolute;
            top: -18px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7em;
            font-weight: 600;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>mythRL Multi-Modal Intelligence</h1>
        <p class="subtitle">Dense, Insightful, Beautiful: Maximum Data Revelation in Minimal Space</p>

        <h2>Performance Bullet Graphs</h2>
        <div class="section-stats">
            <div class="stat-item">
                <span class="stat-badge bg-excellent" style="color: white;">21/21</span>
                <span>Tests Passing</span>
            </div>
            <div class="stat-item">
                <span class="stat-badge bg-good" style="color: white;">138+</span>
                <span>Total Memories</span>
            </div>
            <div class="stat-item">
                <span class="stat-badge bg-fair" style="color: white;">4.63ms</span>
                <span>Avg Search</span>
            </div>
        </div>
        <div class="bullet-grid" id="bulletGrid"></div>

        <h2>Small Multiples: Modality Distribution</h2>
        <div class="section-stats">
            <div class="stat-item">ðŸ“Š 12 Metrics</div>
            <div class="stat-item">ðŸŽ¨ 3 Modalities</div>
            <div class="stat-item">âš¡ Real-time Updates</div>
        </div>
        <div class="small-multiple-grid" id="smallMultiples"></div>

        <h2>Animated Sparklines: Live Metrics</h2>
        <div class="section-stats">
            <div class="stat-item">âœ“ Sub-millisecond latency</div>
            <div class="stat-item">âœ“ 6,000+ ops/sec</div>
            <div class="stat-item">âœ“ 98% confidence</div>
        </div>
        <div class="sparkline-grid" id="sparklineGrid"></div>

        <h2>Distribution Analysis</h2>
        <div class="section-stats">
            <div class="stat-item">ðŸ“ˆ Kernel Density Estimation</div>
            <div class="stat-item">ðŸ“Š Statistical Summaries</div>
        </div>
        <div class="distribution-grid" id="distributionGrid"></div>

        <h2>Compact Histograms: Data Patterns</h2>
        <div class="histogram-grid" id="histogramGrid"></div>

        <h2>Performance Heatmap: Cross-Modal Operations</h2>
        <div class="section-stats">
            <div class="stat-item">3 Modalities Ã— 4 Operations = 12 Metrics</div>
        </div>
        <div class="heatmap-container">
            <svg id="heatmap" width="800" height="300"></svg>
        </div>

        <h2>Comparative Performance</h2>
        <div class="comparison-grid" id="comparisonGrid"></div>

        <h2>Dense Data Table: Complete Statistics</h2>
        <table class="dense-table" id="denseTable"></table>

        <div class="section-stats" style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #e0e0e0;">
            <div class="stat-item">ðŸŽ¯ Designed for insight revelation</div>
            <div class="stat-item">âš¡ Animations show data transformations</div>
            <div class="stat-item">ðŸ“Š Maximum information density</div>
            <div class="stat-item">ðŸŽ¨ Strategic color usage</div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        // Utility functions
        function generateTimeSeries(points = 50, volatility = 10, trend = 0.1) {
            const data = [];
            let value = 50 + Math.random() * 20;
            for (let i = 0; i < points; i++) {
                value += (Math.random() - 0.5) * volatility + trend;
                value = Math.max(0, Math.min(100, value));
                data.push(value);
            }
            return data;
        }

        function getColorByValue(value, max = 100) {
            const ratio = value / max;
            if (ratio >= 0.9) return '#27ae60';
            if (ratio >= 0.75) return '#2ecc71';
            if (ratio >= 0.6) return '#f39c12';
            if (ratio >= 0.4) return '#e74c3c';
            return '#c0392b';
        }

        function getTrendClass(data) {
            const start = data[0];
            const end = data[data.length - 1];
            const change = ((end - start) / start) * 100;
            if (change > 5) return 'trend-up';
            if (change < -5) return 'trend-down';
            return 'trend-flat';
        }

        const tooltip = d3.select('#tooltip');
        
        function showTooltip(content, event) {
            tooltip.html(content)
                .style('display', 'block')
                .style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY - 10) + 'px');
        }
        
        function hideTooltip() {
            tooltip.style('display', 'none');
        }

        // Bullet Graphs - compact and informative
        const bulletData = [
            { label: 'Storage Speed', value: 95, target: 90, ranges: [50, 75, 100] },
            { label: 'Search Accuracy', value: 98, target: 95, ranges: [60, 80, 100] },
            { label: 'Memory Efficiency', value: 85, target: 90, ranges: [50, 70, 100] },
            { label: 'Throughput', value: 92, target: 88, ranges: [55, 75, 100] },
            { label: 'Response Time', value: 88, target: 85, ranges: [60, 80, 100] },
            { label: 'Confidence Score', value: 96, target: 92, ranges: [65, 85, 100] },
            { label: 'Embedding Quality', value: 94, target: 90, ranges: [60, 80, 100] },
            { label: 'Fusion Success', value: 89, target: 85, ranges: [55, 75, 100] },
            { label: 'Graph Density', value: 78, target: 80, ranges: [50, 70, 100] },
            { label: 'Cross-Modal', value: 91, target: 88, ranges: [60, 80, 100] },
            { label: 'Real-time Proc', value: 87, target: 85, ranges: [55, 75, 100] },
            { label: 'Scalability', value: 93, target: 90, ranges: [60, 80, 100] }
        ];

        const bulletGrid = d3.select('#bulletGrid');
        
        bulletData.forEach((d, idx) => {
            const item = bulletGrid.append('div')
                .attr('class', 'bullet-item animated-enter')
                .style('animation-delay', `${idx * 0.05}s`);
            
            item.append('div').attr('class', 'bullet-label').text(d.label);
            
            const viz = item.append('svg').attr('class', 'bullet-viz').attr('width', '100%').attr('height', 24);
            const width = 150;
            const x = d3.scaleLinear().domain([0, 100]).range([0, width]);
            
            // Background ranges
            viz.append('rect').attr('width', x(d.ranges[0])).attr('height', 8).attr('y', 8)
                .attr('fill', '#e0e0e0').attr('rx', 2);
            viz.append('rect').attr('width', x(d.ranges[1])).attr('height', 8).attr('y', 8)
                .attr('fill', '#bdc3c7').attr('rx', 2);
            viz.append('rect').attr('width', x(d.ranges[2])).attr('height', 8).attr('y', 8)
                .attr('fill', '#95a5a6').attr('rx', 2);
            
            // Animated performance bar
            viz.append('rect')
                .attr('width', 0)
                .attr('height', 12)
                .attr('y', 6)
                .attr('fill', getColorByValue(d.value))
                .attr('rx', 2)
                .transition()
                .delay(idx * 50)
                .duration(1000)
                .ease(d3.easeCubicOut)
                .attr('width', x(d.value));
            
            // Target marker
            viz.append('line')
                .attr('x1', x(d.target)).attr('x2', x(d.target))
                .attr('y1', 2).attr('y2', 22)
                .attr('stroke', '#2c3e50')
                .attr('stroke-width', 2)
                .attr('opacity', 0)
                .transition()
                .delay(idx * 50 + 1000)
                .duration(300)
                .attr('opacity', 1);
            
            item.append('div')
                .attr('class', 'bullet-value')
                .style('color', getColorByValue(d.value))
                .text(d.value);
        });

        // Small Multiples - dense grid of trend visualizations
        const smallMultiplesData = [
            { title: 'TEXT Memories', value: 45, unit: '', trend: generateTimeSeries(30, 2, 0.3), color: '#3498db' },
            { title: 'STRUCTURED', value: 38, unit: '', trend: generateTimeSeries(30, 2, 0.2), color: '#2ecc71' },
            { title: 'MULTIMODAL', value: 55, unit: '', trend: generateTimeSeries(30, 3, 0.4), color: '#e74c3c' },
            { title: 'Avg Latency', value: 2.3, unit: 'ms', trend: generateTimeSeries(30, 1, -0.05), color: '#9b59b6' },
            { title: 'Throughput', value: 6209, unit: '/s', trend: generateTimeSeries(30, 8, 1.5), color: '#f39c12' },
            { title: 'Confidence', value: 0.98, unit: '', trend: generateTimeSeries(30, 0.5, 0.01), color: '#1abc9c' },
            { title: 'Memory Usage', value: 30, unit: 'MB', trend: generateTimeSeries(30, 2, 0.1), color: '#e67e22' },
            { title: 'Query Speed', value: 4.63, unit: 'ms', trend: generateTimeSeries(30, 0.5, -0.02), color: '#34495e' },
            { title: 'Graph Nodes', value: 138, unit: '', trend: generateTimeSeries(30, 5, 0.8), color: '#16a085' },
            { title: 'Embeddings', value: 384, unit: 'd', trend: generateTimeSeries(30, 8, 1), color: '#c0392b' },
            { title: 'Fusion Ops', value: 12, unit: '', trend: generateTimeSeries(30, 1, 0.2), color: '#8e44ad' },
            { title: 'Cache Hits', value: 89, unit: '%', trend: generateTimeSeries(30, 3, 0.15), color: '#27ae60' }
        ];

        const smallMultiples = d3.select('#smallMultiples');
        
        smallMultiplesData.forEach((item, idx) => {
            const card = smallMultiples.append('div')
                .attr('class', 'small-multiple animated-enter')
                .style('animation-delay', `${idx * 0.04}s`);
            
            card.append('div').attr('class', 'sm-title').text(item.title);
            
            const valueDiv = card.append('div').attr('class', 'sm-value').style('color', item.color);
            valueDiv.text(typeof item.value === 'number' && item.value < 10 ? item.value.toFixed(2) : item.value);
            if (item.unit) valueDiv.append('span').style('font-size', '0.6em').style('color', '#999').text(' ' + item.unit);
            
            const svg = card.append('svg').attr('class', 'sm-chart').attr('width', '100%').attr('height', 60);
            const width = 160;
            const height = 60;
            const data = item.trend;
            
            const x = d3.scaleLinear().domain([0, data.length - 1]).range([0, width]);
            const y = d3.scaleLinear().domain([0, d3.max(data) * 1.1]).range([height, 0]);
            
            // Area
            const area = d3.area()
                .x((d, i) => x(i))
                .y0(height)
                .y1(d => y(d))
                .curve(d3.curveMonotoneX);
            
            const path = svg.append('path')
                .datum(data)
                .attr('fill', item.color)
                .attr('opacity', 0.2)
                .attr('d', area);
            
            // Line
            const line = d3.line()
                .x((d, i) => x(i))
                .y(d => y(d))
                .curve(d3.curveMonotoneX);
            
            const linePath = svg.append('path')
                .datum(data)
                .attr('fill', 'none')
                .attr('stroke', item.color)
                .attr('stroke-width', 2)
                .attr('d', line);
            
            // Animate line drawing
            const totalLength = linePath.node().getTotalLength();
            linePath
                .attr('stroke-dasharray', totalLength + ' ' + totalLength)
                .attr('stroke-dashoffset', totalLength)
                .transition()
                .delay(idx * 40)
                .duration(1500)
                .ease(d3.easeCubicInOut)
                .attr('stroke-dashoffset', 0);
            
            const change = ((data[data.length - 1] - data[0]) / data[0] * 100).toFixed(1);
            card.append('div')
                .attr('class', `sm-change ${getTrendClass(data)}`)
                .style('color', change > 0 ? '#27ae60' : '#e74c3c')
                .text(`${change > 0 ? '+' : ''}${change}%`);
        });

        // Animated Sparklines
        const sparklineData = [
            { label: 'Storage', current: 0.16, data: generateTimeSeries(60, 0.05, -0.002) },
            { label: 'Search', current: 4.63, data: generateTimeSeries(60, 0.5, 0.01) },
            { label: 'Throughput', current: 6209, data: generateTimeSeries(60, 50, 5) },
            { label: 'Memory', current: 30.5, data: generateTimeSeries(60, 2, 0.1) },
            { label: 'Confidence', current: 0.98, data: generateTimeSeries(60, 0.02, 0.001) },
            { label: 'Embeddings', current: 0.95, data: generateTimeSeries(60, 0.03, 0.002) },
            { label: 'Graph Ops', current: 138, data: generateTimeSeries(60, 8, 0.8) },
            { label: 'Fusion', current: 12, data: generateTimeSeries(60, 1, 0.2) }
        ];

        const sparklineGrid = d3.select('#sparklineGrid');
        
        sparklineData.forEach((metric, idx) => {
            const row = sparklineGrid.append('div')
                .attr('class', 'sparkline-row animated-enter')
                .style('animation-delay', `${idx * 0.06}s`);
            
            row.append('div').attr('class', 'spark-label').text(metric.label);
            
            const svg = row.append('svg').attr('class', 'spark-chart').attr('width', '100%').attr('height', 30);
            const width = 120;
            const height = 30;
            const data = metric.data;
            
            const x = d3.scaleLinear().domain([0, data.length - 1]).range([0, width]);
            const y = d3.scaleLinear().domain([d3.min(data), d3.max(data)]).range([height - 3, 3]);
            
            const line = d3.line()
                .x((d, i) => x(i))
                .y(d => y(d))
                .curve(d3.curveMonotoneX);
            
            const path = svg.append('path')
                .datum(data)
                .attr('fill', 'none')
                .attr('stroke', getColorByValue(metric.current, d3.max(data)))
                .attr('stroke-width', 1.5)
                .attr('d', line);
            
            // Animate drawing
            const totalLength = path.node().getTotalLength();
            path
                .attr('stroke-dasharray', totalLength + ' ' + totalLength)
                .attr('stroke-dashoffset', totalLength)
                .transition()
                .delay(idx * 60 + 200)
                .duration(1200)
                .ease(d3.easeCubicInOut)
                .attr('stroke-dashoffset', 0);
            
            // Current value dot
            svg.append('circle')
                .attr('cx', x(data.length - 1))
                .attr('cy', y(data[data.length - 1]))
                .attr('r', 0)
                .attr('fill', getColorByValue(metric.current, d3.max(data)))
                .transition()
                .delay(idx * 60 + 1400)
                .duration(300)
                .attr('r', 3);
            
            row.append('div')
                .attr('class', 'spark-value')
                .style('color', getColorByValue(metric.current, d3.max(data)))
                .text(metric.current < 1 ? metric.current.toFixed(2) : metric.current.toLocaleString());
            
            const change = ((data[data.length - 1] - data[0]) / data[0] * 100).toFixed(1);
            row.append('div')
                .attr('class', `spark-delta ${getTrendClass(data)}`)
                .style('color', change > 0 ? '#27ae60' : '#e74c3c')
                .text(`${change > 0 ? '+' : ''}${change}%`);
        });

        // Distribution curves
        const distributionData = [
            { title: 'Latency Distribution', mean: 50, std: 10 },
            { title: 'Confidence Scores', mean: 75, std: 8 },
            { title: 'Memory Access', mean: 60, std: 12 },
            { title: 'Query Complexity', mean: 55, std: 15 },
            { title: 'Embedding Similarity', mean: 70, std: 9 },
            { title: 'Fusion Quality', mean: 80, std: 7 },
            { title: 'Graph Centrality', mean: 45, std: 13 },
            { title: 'Processing Time', mean: 65, std: 11 }
        ];

        const distributionGrid = d3.select('#distributionGrid');
        
        distributionData.forEach((dist, idx) => {
            const item = distributionGrid.append('div')
                .attr('class', 'distribution-item animated-enter')
                .style('animation-delay', `${idx * 0.05}s`);
            
            item.append('div').attr('class', 'dist-title').text(dist.title);
            
            const svg = item.append('svg').attr('class', 'dist-chart').attr('width', '100%').attr('height', 80);
            const width = 200;
            const height = 80;
            
            const samples = Array.from({length: 100}, () => d3.randomNormal(dist.mean, dist.std)());
            const bins = d3.bin().domain([0, 100]).thresholds(20)(samples);
            
            const x = d3.scaleLinear().domain([0, 100]).range([0, width]);
            const y = d3.scaleLinear().domain([0, d3.max(bins, d => d.length)]).range([height, 0]);
            
            const area = d3.area()
                .x(d => x(d.x0))
                .y0(height)
                .y1(d => y(d.length))
                .curve(d3.curveBasis);
            
            svg.append('path')
                .datum(bins)
                .attr('fill', `hsl(${idx * 40}, 70%, 60%)`)
                .attr('opacity', 0.6)
                .attr('stroke', `hsl(${idx * 40}, 70%, 40%)`)
                .attr('stroke-width', 1.5)
                .attr('d', area)
                .attr('transform', 'scale(1, 0)')
                .attr('transform-origin', '0 ' + height)
                .transition()
                .delay(idx * 50)
                .duration(800)
                .ease(d3.easeCubicOut)
                .attr('transform', 'scale(1, 1)');
            
            const stats = item.append('div').attr('class', 'dist-stats');
            stats.append('span').text(`Î¼=${dist.mean}`);
            stats.append('span').text(`Ïƒ=${dist.std}`);
        });

        // Compact Histograms
        const histogramData = Array.from({length: 12}, (_, i) => ({
            title: `Metric ${String.fromCharCode(65 + i)}`,
            bars: Array.from({length: 20}, () => Math.random() * 100)
        }));

        const histogramGrid = d3.select('#histogramGrid');
        
        histogramData.forEach((hist, idx) => {
            const item = histogramGrid.append('div')
                .attr('class', 'histogram-item animated-enter')
                .style('animation-delay', `${idx * 0.04}s`);
            
            item.append('div').attr('class', 'histogram-title').text(hist.title);
            
            const container = item.append('div').attr('class', 'histogram-bars');
            
            hist.bars.forEach((value, i) => {
                container.append('div')
                    .attr('class', 'histogram-bar')
                    .style('background', getColorByValue(value))
                    .style('height', '0%')
                    .transition()
                    .delay(idx * 40 + i * 20)
                    .duration(600)
                    .ease(d3.easeBackOut)
                    .style('height', `${value}%`)
                    .on('end', function() {
                        d3.select(this).on('mouseenter', function() {
                            showTooltip(`Value: ${value.toFixed(1)}`, d3.event);
                        }).on('mouseleave', hideTooltip);
                    });
            });
        });

        // Performance Heatmap
        const heatmapData = [
            { modality: 'TEXT', operation: 'Store', value: 95 },
            { modality: 'TEXT', operation: 'Search', value: 88 },
            { modality: 'TEXT', operation: 'Fusion', value: 75 },
            { modality: 'TEXT', operation: 'Extract', value: 92 },
            { modality: 'STRUCTURED', operation: 'Store', value: 98 },
            { modality: 'STRUCTURED', operation: 'Search', value: 92 },
            { modality: 'STRUCTURED', operation: 'Fusion', value: 85 },
            { modality: 'STRUCTURED', operation: 'Extract', value: 96 },
            { modality: 'MULTIMODAL', operation: 'Store', value: 78 },
            { modality: 'MULTIMODAL', operation: 'Search', value: 82 },
            { modality: 'MULTIMODAL', operation: 'Fusion', value: 94 },
            { modality: 'MULTIMODAL', operation: 'Extract', value: 88 }
        ];

        const heatmapSvg = d3.select('#heatmap');
        const cellWidth = 60;
        const cellHeight = 60;
        const heatmapMargin = {top: 80, right: 50, bottom: 50, left: 120};
        
        const modalities = ['TEXT', 'STRUCTURED', 'MULTIMODAL'];
        const operations = ['Store', 'Search', 'Fusion', 'Extract'];
        
        const colorScale = d3.scaleSequential(d3.interpolateRdYlGn).domain([0, 100]);
        
        // Draw cells with animation
        heatmapData.forEach((d, idx) => {
            const xIdx = operations.indexOf(d.operation);
            const yIdx = modalities.indexOf(d.modality);
            
            const cell = heatmapSvg.append('rect')
                .attr('class', 'heatmap-cell')
                .attr('x', heatmapMargin.left + xIdx * cellWidth)
                .attr('y', heatmapMargin.top + yIdx * cellHeight)
                .attr('width', cellWidth - 2)
                .attr('height', cellHeight - 2)
                .attr('fill', colorScale(d.value))
                .attr('opacity', 0)
                .on('mouseenter', function(event) {
                    d3.select(this).attr('opacity', 1);
                    showTooltip(`${d.modality} - ${d.operation}<br/>Score: ${d.value}`, event);
                })
                .on('mouseleave', function() {
                    d3.select(this).attr('opacity', 0.8);
                    hideTooltip();
                });
            
            cell.transition()
                .delay(idx * 80)
                .duration(500)
                .attr('opacity', 0.8);
            
            // Add value text
            heatmapSvg.append('text')
                .attr('x', heatmapMargin.left + xIdx * cellWidth + cellWidth / 2)
                .attr('y', heatmapMargin.top + yIdx * cellHeight + cellHeight / 2)
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .style('font-size', '14px')
                .style('font-weight', 'bold')
                .style('fill', d.value > 50 ? '#333' : '#fff')
                .style('opacity', 0)
                .text(d.value)
                .transition()
                .delay(idx * 80 + 500)
                .duration(300)
                .style('opacity', 1);
        });
        
        // Labels
        operations.forEach((op, i) => {
            heatmapSvg.append('text')
                .attr('x', heatmapMargin.left + i * cellWidth + cellWidth / 2)
                .attr('y', heatmapMargin.top - 10)
                .attr('text-anchor', 'middle')
                .style('font-size', '12px')
                .style('font-weight', 'bold')
                .text(op);
        });
        
        modalities.forEach((mod, i) => {
            heatmapSvg.append('text')
                .attr('x', heatmapMargin.left - 10)
                .attr('y', heatmapMargin.top + i * cellHeight + cellHeight / 2)
                .attr('text-anchor', 'end')
                .attr('dominant-baseline', 'middle')
                .style('font-size', '12px')
                .style('font-weight', 'bold')
                .text(mod);
        });

        // Comparison bars
        const comparisonData = [
            { label: 'Modality Usage', before: [45, 38, 17], after: [40, 35, 25], labels: ['TEXT', 'STRUCT', 'MULTI'] },
            { label: 'Operation Types', before: [30, 25, 25, 20], after: [28, 28, 22, 22], labels: ['Store', 'Search', 'Fusion', 'Extract'] },
            { label: 'Performance Zones', before: [10, 20, 70], after: [5, 15, 80], labels: ['Poor', 'Fair', 'Good'] }
        ];

        const comparisonGrid = d3.select('#comparisonGrid');
        
        comparisonData.forEach((comp, idx) => {
            const item = comparisonGrid.append('div')
                .attr('class', 'comparison-item animated-enter')
                .style('animation-delay', `${idx * 0.1}s`);
            
            const label = item.append('div').attr('class', 'comparison-label');
            label.append('span').text(comp.label);
            label.append('span').style('color', '#999').text('Before â†’ After');
            
            const container = item.append('div').attr('class', 'comparison-bars');
            
            comp.before.forEach((beforeVal, i) => {
                const afterVal = comp.after[i];
                const color = `hsl(${i * 60}, 70%, 60%)`;
                
                const barContainer = container.append('div')
                    .style('flex', '1')
                    .style('position', 'relative')
                    .style('display', 'flex')
                    .style('flex-direction', 'column')
                    .style('gap', '2px')
                    .style('height', '100%');
                
                // Before bar
                barContainer.append('div')
                    .attr('class', 'comparison-bar')
                    .style('background', color)
                    .style('opacity', '0.4')
                    .style('height', '0%')
                    .transition()
                    .delay(idx * 100 + i * 50)
                    .duration(800)
                    .ease(d3.easeBackOut)
                    .style('height', `${beforeVal * 3}px`);
                
                // After bar
                barContainer.append('div')
                    .attr('class', 'comparison-bar')
                    .style('background', color)
                    .style('height', '0%')
                    .transition()
                    .delay(idx * 100 + i * 50 + 400)
                    .duration(800)
                    .ease(d3.easeBackOut)
                    .style('height', `${afterVal * 3}px`);
                
                // Label
                barContainer.append('div')
                    .style('font-size', '0.7em')
                    .style('text-align', 'center')
                    .style('margin-top', '5px')
                    .style('color', '#666')
                    .text(comp.labels[i]);
            });
        });

        // Dense table with inline visualizations
        const tableData = [
            { demo: 'Quantum Research', memories: 15, modality: 'TEXT', latency: 2.3, confidence: 0.98, ops: 145, trend: generateTimeSeries(20, 1, 0.1) },
            { demo: 'AI Healthcare', memories: 11, modality: 'STRUCTURED', latency: 3.1, confidence: 0.95, ops: 132, trend: generateTimeSeries(20, 1.2, -0.05) },
            { demo: 'Real-time Pipeline', memories: 100, modality: 'TEXT', latency: 0.16, confidence: 0.92, ops: 6209, trend: generateTimeSeries(20, 2, 0.3) },
            { demo: 'Knowledge Synthesis', memories: 12, modality: 'MULTIMODAL', latency: 4.5, confidence: 0.98, ops: 156, trend: generateTimeSeries(20, 0.8, 0.05) }
        ];

        const table = d3.select('#denseTable');
        const thead = table.append('thead').append('tr');
        ['Demo', 'Count', 'Type', 'Latency', 'Conf', 'Ops/s', 'Trend', 'Status'].forEach(header => {
            thead.append('th').text(header);
        });

        const tbody = table.append('tbody');
        tableData.forEach((row, idx) => {
            const tr = tbody.append('tr')
                .style('opacity', 0)
                .transition()
                .delay(idx * 100)
                .duration(500)
                .style('opacity', 1);
            
            tr.append('td').text(row.demo);
            tr.append('td').text(row.memories);
            
            const modalityCell = tr.append('td');
            modalityCell.append('span')
                .attr('class', 'inline-dot')
                .style('background', row.modality === 'TEXT' ? '#3498db' : row.modality === 'STRUCTURED' ? '#2ecc71' : '#e74c3c');
            modalityCell.append('span').text(row.modality.substring(0, 4));
            
            tr.append('td').text(row.latency + 'ms');
            tr.append('td').text(row.confidence);
            tr.append('td').text(row.ops.toLocaleString());
            
            const trendCell = tr.append('td');
            trendCell.append('div')
                .attr('class', 'inline-bar animated-grow')
                .style('width', `${Math.min(100, row.ops / 100)}px`)
                .style('animation-delay', `${idx * 100}ms`);
            
            const statusCell = tr.append('td');
            const avgValue = row.trend.reduce((a, b) => a + b, 0) / row.trend.length;
            statusCell.append('span')
                .attr('class', 'stat-badge')
                .style('background', getColorByValue(avgValue))
                .style('color', 'white')
                .text(avgValue > 75 ? 'GOOD' : avgValue > 50 ? 'FAIR' : 'POOR');
        });

        console.log('Dense, insightful dashboard loaded with animated data revelations!');
    </script>
</body>
</html>