"""
Resource-Constrained Planning for Layer 2

Implements planning under resource constraints:
- Resource tracking (consumable, reusable, producible)
- Budget and deadline constraints
- Resource allocation optimization
- Feasibility checking
- Plan repair for resource violations

Research:
- Ghallab et al. (2004): "Automated Planning" (resource constraints)
- Coles et al. (2009): COLIN - Planning with continuous numeric change
- Fox & Long (2003): PDDL2.1 - Numeric planning
"""

from dataclasses import dataclass, field
from typing import List, Dict, Optional, Set, Tuple
from enum import Enum
import logging
from copy import deepcopy

# Import Layer 2 core
from HoloLoom.planning.planner import HierarchicalPlanner, Plan, Goal, Action

logger = logging.getLogger(__name__)


# ============================================================================
# Enums and Core Types
# ============================================================================

class ResourceType(Enum):
    """Type of resource."""
    CONSUMABLE = "consumable"    # Used up (fuel, materials)
    REUSABLE = "reusable"        # Held temporarily (tools, rooms)
    PRODUCIBLE = "producible"    # Generated by actions (products)


class ViolationType(Enum):
    """Type of resource constraint violation."""
    CAPACITY = "capacity"        # Exceeds capacity
    BUDGET = "budget"           # Exceeds budget
    DEADLINE = "deadline"       # Exceeds deadline
    UNAVAILABLE = "unavailable"  # Resource not available


# ============================================================================
# Resource Definitions
# ============================================================================

@dataclass
class Resource:
    """Resource definition."""
    name: str
    resource_type: ResourceType
    initial_amount: float
    capacity: Optional[float] = None  # Max at any time (None = unlimited)
    cost_per_unit: float = 0.0        # Monetary cost per unit
    replenish_rate: float = 0.0       # Units per time step (for renewable)

    def __repr__(self):
        cap_str = f", cap={self.capacity}" if self.capacity else ""
        return (f"Resource({self.name}, {self.resource_type.value}, "
                f"init={self.initial_amount}{cap_str})")


@dataclass
class ResourceRequirement:
    """Resources required by an action."""
    resource: str
    amount: float
    when: str = "start"  # "start", "end", "duration"

    def __repr__(self):
        return f"Req({self.resource}={self.amount} @ {self.when})"


@dataclass
class ResourceState:
    """State of resources at a point in time."""
    time: float
    available: Dict[str, float]  # resource_name -> amount available
    allocated: Dict[str, float]  # resource_name -> amount currently held
    produced: Dict[str, float] = field(default_factory=dict)  # Produced so far

    def total(self, resource: str) -> float:
        """Total resource (available + allocated)."""
        return self.available.get(resource, 0) + self.allocated.get(resource, 0)

    def __repr__(self):
        return f"ResourceState(t={self.time:.1f}, avail={self.available})"


@dataclass
class ResourceViolation:
    """Resource constraint violation."""
    violation_type: ViolationType
    resource: str
    action: Action
    time: float
    required: float
    available: float
    message: str

    def __repr__(self):
        return f"{self.violation_type.value}: {self.message}"


# ============================================================================
# Resource Tracking
# ============================================================================

class ResourceTracker:
    """Tracks resource usage over time."""

    def __init__(self, resources: List[Resource]):
        """
        Initialize tracker.

        Args:
            resources: List of available resources
        """
        self.resources = {r.name: r for r in resources}
        self.timeline: List[ResourceState] = []

        # Initialize timeline at t=0
        initial_state = ResourceState(
            time=0.0,
            available={r.name: r.initial_amount for r in resources},
            allocated={r.name: 0.0 for r in resources}
        )
        self.timeline.append(initial_state)

        logger.info(f"Initialized ResourceTracker with {len(resources)} resources")

    # ------------------------------------------------------------------------
    # State Management
    # ------------------------------------------------------------------------

    def get_state_at(self, time: float) -> ResourceState:
        """Get resource state at specific time."""
        # Find closest state
        for state in reversed(self.timeline):
            if state.time <= time:
                return deepcopy(state)

        # Before first state
        return deepcopy(self.timeline[0])

    def update_state(self, new_state: ResourceState):
        """Add new state to timeline."""
        self.timeline.append(new_state)
        self.timeline.sort(key=lambda s: s.time)

    # ------------------------------------------------------------------------
    # Feasibility Checking
    # ------------------------------------------------------------------------

    def check_feasibility(self, plan: Plan,
                         constraints: Optional[Dict[str, float]] = None) -> bool:
        """
        Check if plan is feasible given resources.

        Args:
            plan: Plan to check
            constraints: Additional constraints (e.g., {"budget": 1000, "deadline": 100})

        Returns:
            True if feasible, False otherwise
        """
        violations = self.find_violations(plan, constraints)
        return len(violations) == 0

    def find_violations(self, plan: Plan,
                       constraints: Optional[Dict[str, float]] = None) -> List[ResourceViolation]:
        """
        Find all resource constraint violations in plan.

        Args:
            plan: Plan to check
            constraints: Additional constraints

        Returns:
            List of violations (empty if feasible)
        """
        violations = []
        constraints = constraints or {}

        # Simulate plan execution
        timeline = self.simulate_plan(plan)

        # Check violations at each time step
        for state in timeline:
            # Check capacity constraints
            for resource_name, resource in self.resources.items():
                total = state.total(resource_name)

                if resource.capacity is not None and total > resource.capacity:
                    violations.append(ResourceViolation(
                        violation_type=ViolationType.CAPACITY,
                        resource=resource_name,
                        action=None,  # TODO: Find causing action
                        time=state.time,
                        required=total,
                        available=resource.capacity,
                        message=f"{resource_name} exceeds capacity "
                                f"({total:.2f} > {resource.capacity:.2f})"
                    ))

                # Check availability
                if state.available[resource_name] < 0:
                    violations.append(ResourceViolation(
                        violation_type=ViolationType.UNAVAILABLE,
                        resource=resource_name,
                        action=None,
                        time=state.time,
                        required=-state.available[resource_name],
                        available=0,
                        message=f"{resource_name} unavailable "
                                f"(deficit: {-state.available[resource_name]:.2f})"
                    ))

        # Check budget constraint
        if "budget" in constraints:
            total_cost = self.calculate_total_cost(plan)
            if total_cost > constraints["budget"]:
                violations.append(ResourceViolation(
                    violation_type=ViolationType.BUDGET,
                    resource="money",
                    action=None,
                    time=0,
                    required=total_cost,
                    available=constraints["budget"],
                    message=f"Budget exceeded ({total_cost:.2f} > {constraints['budget']:.2f})"
                ))

        # Check deadline constraint
        if "deadline" in constraints:
            total_time = self.calculate_total_time(plan)
            if total_time > constraints["deadline"]:
                violations.append(ResourceViolation(
                    violation_type=ViolationType.DEADLINE,
                    resource="time",
                    action=None,
                    time=total_time,
                    required=total_time,
                    available=constraints["deadline"],
                    message=f"Deadline exceeded ({total_time:.2f} > {constraints['deadline']:.2f})"
                ))

        return violations

    # ------------------------------------------------------------------------
    # Plan Simulation
    # ------------------------------------------------------------------------

    def simulate_plan(self, plan: Plan) -> List[ResourceState]:
        """
        Simulate plan execution to get resource timeline.

        Args:
            plan: Plan to simulate

        Returns:
            Timeline of resource states
        """
        timeline = [deepcopy(self.timeline[0])]  # Start from initial
        current_time = 0.0

        for i, action in enumerate(plan.actions):
            # Get action duration and requirements
            duration = getattr(action, 'duration', 1.0)
            requirements = getattr(action, 'requirements', [])

            # Current state
            current_state = timeline[-1]
            next_state = deepcopy(current_state)
            next_state.time = current_time + duration

            # Apply resource changes
            for req in requirements:
                resource_name = req.resource
                amount = req.amount
                resource = self.resources[resource_name]

                if req.when == "start":
                    # Consume/allocate at start
                    if resource.resource_type == ResourceType.CONSUMABLE:
                        next_state.available[resource_name] -= amount
                    elif resource.resource_type == ResourceType.REUSABLE:
                        next_state.allocated[resource_name] += amount
                        next_state.available[resource_name] -= amount

                elif req.when == "end":
                    # Apply at end
                    if resource.resource_type == ResourceType.PRODUCIBLE:
                        next_state.available[resource_name] += amount
                        next_state.produced[resource_name] = \
                            next_state.produced.get(resource_name, 0) + amount
                    elif resource.resource_type == ResourceType.REUSABLE:
                        # Release resource
                        next_state.allocated[resource_name] -= amount
                        next_state.available[resource_name] += amount

                elif req.when == "duration":
                    # Consume over duration
                    if resource.resource_type == ResourceType.CONSUMABLE:
                        next_state.available[resource_name] -= amount

            timeline.append(next_state)
            current_time += duration

        return timeline

    # ------------------------------------------------------------------------
    # Cost & Time Calculation
    # ------------------------------------------------------------------------

    def calculate_total_cost(self, plan: Plan) -> float:
        """Calculate total monetary cost of plan."""
        total_cost = 0.0

        for action in plan.actions:
            requirements = getattr(action, 'requirements', [])
            for req in requirements:
                resource = self.resources.get(req.resource)
                if resource:
                    total_cost += req.amount * resource.cost_per_unit

        return total_cost

    def calculate_total_time(self, plan: Plan) -> float:
        """Calculate total execution time of plan."""
        total_time = 0.0

        for action in plan.actions:
            duration = getattr(action, 'duration', 1.0)
            total_time += duration

        return total_time

    # ------------------------------------------------------------------------
    # Resource Optimization
    # ------------------------------------------------------------------------

    def compute_resource_usage(self, plan: Plan) -> Dict[str, Dict[str, float]]:
        """
        Compute detailed resource usage statistics.

        Returns:
            Dict of resource_name -> {consumed, peak_allocated, produced}
        """
        timeline = self.simulate_plan(plan)
        usage = {}

        for resource_name in self.resources.keys():
            initial = timeline[0].available[resource_name]
            final = timeline[-1].available[resource_name]
            consumed = initial - final

            peak_allocated = max(s.allocated[resource_name] for s in timeline)
            produced = timeline[-1].produced.get(resource_name, 0.0)

            usage[resource_name] = {
                'consumed': consumed,
                'peak_allocated': peak_allocated,
                'produced': produced,
                'net_change': final - initial
            }

        return usage


# ============================================================================
# Resource-Aware Planner
# ============================================================================

class ResourceAwarePlanner:
    """Planner with resource constraint awareness."""

    def __init__(self,
                 base_planner: HierarchicalPlanner,
                 resources: List[Resource],
                 constraints: Optional[Dict[str, float]] = None):
        """
        Initialize resource-aware planner.

        Args:
            base_planner: Base hierarchical planner
            resources: Available resources
            constraints: Global constraints (budget, deadline)
        """
        self.base_planner = base_planner
        self.tracker = ResourceTracker(resources)
        self.constraints = constraints or {}

        logger.info(f"Initialized ResourceAwarePlanner with {len(resources)} resources")

    # ------------------------------------------------------------------------
    # Planning
    # ------------------------------------------------------------------------

    def plan(self, goal: Goal, current_state: Dict,
             max_repair_attempts: int = 3) -> Optional[Plan]:
        """
        Generate resource-feasible plan.

        Algorithm:
        1. Generate candidate plan (base planner)
        2. Check resource feasibility
        3. If infeasible, attempt repair
        4. If repair fails, return None

        Args:
            goal: Planning goal
            current_state: Current world state
            max_repair_attempts: Max attempts to repair plan

        Returns:
            Feasible plan or None
        """
        logger.info(f"Planning for goal: {goal}")

        # Step 1: Generate base plan
        plan = self.base_planner.plan(goal, current_state)
        if not plan:
            logger.warning("Base planner failed to generate plan")
            return None

        # Step 2: Check feasibility
        violations = self.tracker.find_violations(plan, self.constraints)

        if not violations:
            logger.info(f"✓ Plan is resource-feasible ({len(plan.actions)} actions)")
            return plan

        # Step 3: Attempt repair
        logger.warning(f"Plan has {len(violations)} resource violations, attempting repair...")

        for attempt in range(max_repair_attempts):
            plan = self.repair_plan(plan, violations)
            if not plan:
                break

            violations = self.tracker.find_violations(plan, self.constraints)
            if not violations:
                logger.info(f"✓ Plan repaired successfully (attempt {attempt+1})")
                return plan

        logger.error(f"Failed to repair plan after {max_repair_attempts} attempts")
        return None

    # ------------------------------------------------------------------------
    # Plan Repair
    # ------------------------------------------------------------------------

    def repair_plan(self, plan: Plan, violations: List[ResourceViolation]) -> Optional[Plan]:
        """
        Repair plan to fix resource violations.

        Strategies:
        - Budget violations: Remove expensive actions
        - Deadline violations: Shorten plan
        - Capacity violations: Add resource release actions
        - Unavailability: Add resource acquisition actions

        Args:
            plan: Plan with violations
            violations: List of violations to fix

        Returns:
            Repaired plan or None if unfixable
        """
        repaired = deepcopy(plan)

        for violation in violations:
            if violation.violation_type == ViolationType.BUDGET:
                # Remove most expensive action
                repaired = self._remove_expensive_actions(repaired, violation)

            elif violation.violation_type == ViolationType.DEADLINE:
                # Remove slowest action
                repaired = self._remove_slow_actions(repaired, violation)

            elif violation.violation_type == ViolationType.CAPACITY:
                # Add resource release (if reusable)
                # For now, just log - TODO: Implement
                logger.warning(f"Cannot auto-repair capacity violation: {violation}")

            elif violation.violation_type == ViolationType.UNAVAILABLE:
                # Add resource acquisition
                # For now, just log - TODO: Implement
                logger.warning(f"Cannot auto-repair unavailability: {violation}")

        return repaired

    def _remove_expensive_actions(self, plan: Plan,
                                  violation: ResourceViolation) -> Plan:
        """Remove most expensive action to meet budget."""
        # TODO: Implement smart action removal
        # For now, simple: remove last action
        if plan.actions:
            removed = plan.actions.pop()
            logger.info(f"Removed action {removed} to reduce cost")
        return plan

    def _remove_slow_actions(self, plan: Plan,
                            violation: ResourceViolation) -> Plan:
        """Remove slowest action to meet deadline."""
        # TODO: Implement smart action removal
        # For now, simple: remove last action
        if plan.actions:
            removed = plan.actions.pop()
            logger.info(f"Removed action {removed} to reduce time")
        return plan

    # ------------------------------------------------------------------------
    # Optimization
    # ------------------------------------------------------------------------

    def optimize_resources(self, plan: Plan, objective: str = "minimize_cost") -> Plan:
        """
        Optimize plan for resource usage.

        Objectives:
        - minimize_cost: Cheapest plan
        - minimize_time: Fastest plan
        - balance: Pareto-optimal tradeoff

        Args:
            plan: Plan to optimize
            objective: Optimization objective

        Returns:
            Optimized plan
        """
        if objective == "minimize_cost":
            return self._optimize_cost(plan)
        elif objective == "minimize_time":
            return self._optimize_time(plan)
        elif objective == "balance":
            return self._optimize_balance(plan)
        else:
            logger.warning(f"Unknown objective: {objective}")
            return plan

    def _optimize_cost(self, plan: Plan) -> Plan:
        """Optimize for minimum cost."""
        # TODO: Implement cost optimization
        # For now, return original
        return plan

    def _optimize_time(self, plan: Plan) -> Plan:
        """Optimize for minimum time."""
        # TODO: Implement time optimization
        # For now, return original
        return plan

    def _optimize_balance(self, plan: Plan) -> Plan:
        """Find Pareto-optimal cost/time balance."""
        # TODO: Implement multi-objective optimization
        # For now, return original
        return plan


# ============================================================================
# Resource Allocation Optimizer
# ============================================================================

class ResourceAllocator:
    """Optimizes resource allocation across multiple plans."""

    def __init__(self, resources: List[Resource]):
        """Initialize allocator."""
        self.resources = {r.name: r for r in resources}

    def allocate(self, plans: List[Tuple[str, Plan, float]]) -> Dict[str, Plan]:
        """
        Allocate resources to plans optimally.

        Args:
            plans: List of (plan_id, plan, priority) tuples

        Returns:
            Dict of plan_id -> allocated_plan (may modify plans to fit resources)
        """
        # Sort by priority (high to low)
        sorted_plans = sorted(plans, key=lambda x: x[2], reverse=True)

        allocated = {}
        remaining_resources = {
            name: resource.initial_amount
            for name, resource in self.resources.items()
        }

        for plan_id, plan, priority in sorted_plans:
            # Check if resources available
            required = self._calculate_requirements(plan)

            if self._can_allocate(required, remaining_resources):
                # Allocate
                allocated[plan_id] = plan
                for resource, amount in required.items():
                    remaining_resources[resource] -= amount
                logger.info(f"Allocated resources to plan {plan_id}")
            else:
                logger.warning(f"Insufficient resources for plan {plan_id}")

        return allocated

    def _calculate_requirements(self, plan: Plan) -> Dict[str, float]:
        """Calculate total resource requirements for plan."""
        requirements = {}

        for action in plan.actions:
            action_reqs = getattr(action, 'requirements', [])
            for req in action_reqs:
                resource = req.resource
                amount = req.amount
                requirements[resource] = requirements.get(resource, 0) + amount

        return requirements

    def _can_allocate(self, required: Dict[str, float],
                     available: Dict[str, float]) -> bool:
        """Check if allocation is possible."""
        for resource, amount in required.items():
            if amount > available.get(resource, 0):
                return False
        return True


# ============================================================================
# Exports
# ============================================================================

__all__ = [
    'Resource',
    'ResourceType',
    'ResourceRequirement',
    'ResourceState',
    'ResourceViolation',
    'ViolationType',
    'ResourceTracker',
    'ResourceAwarePlanner',
    'ResourceAllocator',
]
