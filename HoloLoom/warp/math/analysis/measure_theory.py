"""
Measure Theory for HoloLoom Warp Drive
======================================

Rigorous integration theory and probability foundations.

Core Concepts:
- Sigma-Algebras: Measurable sets
- Measures: Lebesgue measure, probability measures
- Measurable Functions: Integration domain
- Lebesgue Integration: Generalized Riemann integration
- Convergence Theorems: MCT, Fatou, DCT

Mathematical Foundation:
A measure space is a triple (X, Σ, μ) where:
- X is a set (the space)
- Σ is a sigma-algebra on X (measurable sets)
- μ: Σ → [0, ∞] is a countably additive set function

Lebesgue integral: ∫ f dμ = lim ∫ sₙ dμ for simple functions sₙ ↗ f

Applications to Warp Space:
- Probability measures on feature spaces
- Lebesgue integration for neural network loss functions
- Convergence theorems for training dynamics
- Measure-theoretic probability for uncertainty quantification

Author: HoloLoom Team
Date: 2025-10-26
"""

import numpy as np
from typing import Callable, List, Set, Tuple, Optional, Union, FrozenSet, Any
from dataclasses import dataclass
import logging

logger = logging.getLogger(__name__)


# ============================================================================
# SIGMA-ALGEBRAS
# ============================================================================

class SigmaAlgebra:
    """
    Sigma-algebra: Collection of measurable sets.

    A sigma-algebra Σ on X satisfies:
    1. X ∈ Σ
    2. A ∈ Σ ⟹ Aᶜ ∈ Σ (closed under complements)
    3. A₁, A₂, ... ∈ Σ ⟹ ⋃ Aᵢ ∈ Σ (closed under countable unions)
    """

    def __init__(self, space: Set, sets: List[FrozenSet]):
        """
        Initialize sigma-algebra.

        Args:
            space: The universal set X
            sets: Initial collection of measurable sets
        """
        self.space = frozenset(space)
        self.sets = {frozenset(s) for s in sets}

        logger.info(f"Sigma-algebra on space of size {len(self.space)}")

    def contains(self, subset: Set) -> bool:
        """Check if subset is measurable (in sigma-algebra)."""
        return frozenset(subset) in self.sets

    def complement(self, subset: Set) -> FrozenSet:
        """Compute complement of subset."""
        return self.space - frozenset(subset)

    def union(self, subsets: List[Set]) -> FrozenSet:
        """Compute union of subsets."""
        result = frozenset()
        for s in subsets:
            result = result | frozenset(s)
        return result

    def intersection(self, subsets: List[Set]) -> FrozenSet:
        """Compute intersection of subsets."""
        if not subsets:
            return self.space

        result = frozenset(subsets[0])
        for s in subsets[1:]:
            result = result & frozenset(s)
        return result

    @staticmethod
    def generate_from_sets(space: Set, generating_sets: List[Set]) -> 'SigmaAlgebra':
        """
        Generate smallest sigma-algebra containing generating_sets.

        This is the "sigma-algebra generated by" construction.
        """
        space_frozen = frozenset(space)

        # Start with generating sets, their complements, and empty set
        sigma_sets = {frozenset()}
        sigma_sets.add(space_frozen)

        for s in generating_sets:
            sigma_sets.add(frozenset(s))
            sigma_sets.add(space_frozen - frozenset(s))

        # Add finite unions and intersections
        # (For finite spaces, this is sufficient)
        changed = True
        iterations = 0
        max_iterations = 100

        while changed and iterations < max_iterations:
            changed = False
            iterations += 1
            new_sets = set(sigma_sets)

            # Add complements
            for s in sigma_sets:
                complement = space_frozen - s
                if complement not in sigma_sets:
                    new_sets.add(complement)
                    changed = True

            # Add pairwise unions
            sigma_list = list(sigma_sets)
            for i, s1 in enumerate(sigma_list):
                for s2 in sigma_list[i:]:
                    union = s1 | s2
                    if union not in sigma_sets:
                        new_sets.add(union)
                        changed = True

            sigma_sets = new_sets

            # Limit size for practical reasons
            if len(sigma_sets) > 10000:
                break

        return SigmaAlgebra(space, list(sigma_sets))

    @staticmethod
    def power_set_algebra(space: Set) -> 'SigmaAlgebra':
        """
        Create power set sigma-algebra (all subsets measurable).

        Only practical for small spaces.
        """
        space_list = list(space)
        n = len(space_list)

        if n > 10:
            logger.warning(f"Power set of size 2^{n} is large. Using subset.")
            # Only include some subsets
            subsets = [frozenset()]
            subsets.append(frozenset(space))
            for elem in space_list:
                subsets.append(frozenset([elem]))
            return SigmaAlgebra(space, subsets)

        # Generate all 2^n subsets
        from itertools import combinations

        subsets = []
        for r in range(n + 1):
            for subset in combinations(space_list, r):
                subsets.append(frozenset(subset))

        return SigmaAlgebra(space, subsets)


# ============================================================================
# MEASURES
# ============================================================================

class Measure:
    """
    Measure: Countably additive set function.

    μ: Σ → [0, ∞] with:
    1. μ(∅) = 0
    2. μ(⋃ Aᵢ) = Σ μ(Aᵢ) for disjoint Aᵢ (countable additivity)
    """

    def __init__(self, sigma_algebra: SigmaAlgebra,
                 measure_function: Optional[Callable[[FrozenSet], float]] = None):
        """
        Initialize measure.

        Args:
            sigma_algebra: The sigma-algebra of measurable sets
            measure_function: Function assigning measure to each set
        """
        self.sigma_algebra = sigma_algebra

        if measure_function is None:
            # Default: counting measure
            measure_function = lambda s: float(len(s))

        self.measure_function = measure_function

        logger.info(f"Measure on sigma-algebra with {len(sigma_algebra.sets)} sets")

    def __call__(self, subset: Union[Set, FrozenSet]) -> float:
        """Evaluate measure μ(A)."""
        subset_frozen = frozenset(subset)

        if not self.sigma_algebra.contains(subset):
            raise ValueError(f"Set {subset} is not measurable")

        return self.measure_function(subset_frozen)

    def is_probability_measure(self) -> bool:
        """Check if μ(X) = 1 (probability measure)."""
        total = self.measure_function(self.sigma_algebra.space)
        return abs(total - 1.0) < 1e-10

    def is_finite(self) -> bool:
        """Check if μ(X) < ∞."""
        total = self.measure_function(self.sigma_algebra.space)
        return np.isfinite(total)

    @staticmethod
    def counting_measure(sigma_algebra: SigmaAlgebra) -> 'Measure':
        """Counting measure: μ(A) = |A|."""
        return Measure(sigma_algebra, lambda s: float(len(s)))

    @staticmethod
    def uniform_measure(sigma_algebra: SigmaAlgebra) -> 'Measure':
        """Uniform probability measure: μ(A) = |A| / |X|."""
        total_size = len(sigma_algebra.space)
        return Measure(sigma_algebra, lambda s: len(s) / total_size)

    @staticmethod
    def dirac_measure(sigma_algebra: SigmaAlgebra, point) -> 'Measure':
        """Dirac measure: δₓ(A) = 1 if x ∈ A, 0 otherwise."""
        def dirac(s: FrozenSet) -> float:
            return 1.0 if point in s else 0.0

        return Measure(sigma_algebra, dirac)


# ============================================================================
# LEBESGUE MEASURE (1D)
# ============================================================================

class LebesgueMeasure:
    """
    Lebesgue measure on ℝ.

    For intervals: λ([a, b]) = b - a
    For general sets: Outer measure via coverings by intervals
    """

    @staticmethod
    def measure_interval(a: float, b: float) -> float:
        """
        Measure of interval [a, b].

        λ([a, b]) = b - a
        """
        if a > b:
            return 0.0
        return b - a

    @staticmethod
    def outer_measure_1d(points: np.ndarray, epsilon: float = 1e-6) -> float:
        """
        Lebesgue outer measure of finite point set in ℝ.

        λ*(E) = inf {Σ |Iₙ| : E ⊆ ⋃ Iₙ}

        For finite sets, outer measure is 0.
        """
        # Finite sets have measure 0
        return 0.0

    @staticmethod
    def measure_nd(bounds: List[Tuple[float, float]]) -> float:
        """
        Lebesgue measure of n-dimensional box.

        λ([a₁,b₁] × ... × [aₙ,bₙ]) = ∏(bᵢ - aᵢ)
        """
        measure = 1.0
        for a, b in bounds:
            if a > b:
                return 0.0
            measure *= (b - a)
        return measure


# ============================================================================
# MEASURABLE FUNCTIONS
# ============================================================================

class MeasurableFunction:
    """
    Measurable function f: X → ℝ.

    f is measurable if f⁻¹(B) ∈ Σ for all Borel sets B ⊆ ℝ.
    """

    def __init__(self, function: Callable[[Any], float],
                 domain_sigma: SigmaAlgebra):
        """
        Initialize measurable function.

        Args:
            function: The function f: X → ℝ
            domain_sigma: Sigma-algebra on domain
        """
        self.function = function
        self.domain_sigma = domain_sigma

    def __call__(self, x) -> float:
        """Evaluate f(x)."""
        return self.function(x)

    def preimage(self, threshold: float) -> FrozenSet:
        """
        Preimage f⁻¹((-∞, threshold]).

        For measurability, this should be in domain sigma-algebra.
        """
        preimage_set = {
            x for x in self.domain_sigma.space
            if self.function(x) <= threshold
        }
        return frozenset(preimage_set)

    def is_measurable(self, test_thresholds: Optional[List[float]] = None) -> bool:
        """
        Check if function is measurable.

        Tests if f⁻¹((-∞, t]) ∈ Σ for sample thresholds.
        """
        if test_thresholds is None:
            # Sample thresholds
            values = [self.function(x) for x in self.domain_sigma.space]
            test_thresholds = np.linspace(min(values), max(values), 10)

        for t in test_thresholds:
            preimage = self.preimage(t)
            if not self.domain_sigma.contains(preimage):
                return False

        return True


# ============================================================================
# LEBESGUE INTEGRATION
# ============================================================================

class LebesgueIntegrator:
    """
    Lebesgue integration via simple function approximation.

    For simple function s = Σ αᵢ χ_Aᵢ:
    ∫ s dμ = Σ αᵢ μ(Aᵢ)

    For general f ≥ 0:
    ∫ f dμ = sup {∫ s dμ : 0 ≤ s ≤ f, s simple}
    """

    @staticmethod
    def integrate_simple_function(
        coefficients: List[float],
        sets: List[FrozenSet],
        measure: Measure
    ) -> float:
        """
        Integrate simple function s = Σ αᵢ χ_Aᵢ.

        ∫ s dμ = Σ αᵢ μ(Aᵢ)
        """
        integral = 0.0

        for alpha, A in zip(coefficients, sets):
            integral += alpha * measure(A)

        return integral

    @staticmethod
    def integrate_discrete(
        function: MeasurableFunction,
        measure: Measure
    ) -> float:
        """
        Integrate measurable function on discrete space.

        ∫ f dμ = Σ f(x) μ({x})
        """
        integral = 0.0

        for x in measure.sigma_algebra.space:
            singleton = frozenset([x])
            if measure.sigma_algebra.contains(singleton):
                integral += function(x) * measure(singleton)

        return integral

    @staticmethod
    def integrate_continuous_1d(
        f: Callable[[float], float],
        a: float,
        b: float,
        n_points: int = 1000
    ) -> float:
        """
        Approximate Lebesgue integral on [a, b] via simple functions.

        For continuous f, approximates with simple functions:
        s_n(x) = sum_i f(x_i) * chi_{[x_i, x_{i+1})}(x)

        NOTE: For continuous functions on bounded intervals,
        Riemann and Lebesgue integrals coincide, so we use
        Simpson's rule which converges to both.
        """
        # For continuous functions: Lebesgue = Riemann
        # Use Simpson's rule (efficient and accurate)
        if n_points % 2 == 1:
            n_points += 1

        h = (b - a) / n_points
        x = np.linspace(a, b, n_points + 1)
        y = np.array([f(xi) for xi in x])

        # Simpson's rule
        integral = h / 3 * (
            y[0] + y[-1] +
            4 * np.sum(y[1:-1:2]) +
            2 * np.sum(y[2:-2:2])
        )

        return integral

    @staticmethod
    def integrate_simple_function_lebesgue(
        values: np.ndarray,
        intervals: List[Tuple[float, float]]
    ) -> float:
        """
        TRUE Lebesgue integration via simple functions.

        For simple function s = sum_i a_i * chi_{E_i}:
        ∫ s dλ = sum_i a_i * λ(E_i)

        Args:
            values: Coefficients [a_1, ..., a_n]
            intervals: Measurable sets [(a_1,b_1), ..., (a_n,b_n)]

        Returns:
            Lebesgue integral
        """
        integral = 0.0
        for value, (a, b) in zip(values, intervals):
            measure = LebesgueMeasure.measure_interval(a, b)
            integral += value * measure

        logger.info(f"Lebesgue integral via simple functions: {integral}")
        return integral


# ============================================================================
# CONVERGENCE THEOREMS
# ============================================================================

class ConvergenceTheorems:
    """
    Classical convergence theorems for Lebesgue integration.

    - Monotone Convergence Theorem (MCT)
    - Fatou's Lemma
    - Dominated Convergence Theorem (DCT)
    """

    @staticmethod
    def verify_monotone_convergence(
        sequence_functions: List[MeasurableFunction],
        limit_function: MeasurableFunction,
        measure: Measure,
        tolerance: float = 1e-6
    ) -> bool:
        """
        Verify Monotone Convergence Theorem.

        If 0 ≤ f₁ ≤ f₂ ≤ ... and fₙ → f, then:
        ∫ f dμ = lim ∫ fₙ dμ
        """
        # Check monotonicity
        for i in range(len(sequence_functions) - 1):
            for x in measure.sigma_algebra.space:
                if sequence_functions[i](x) > sequence_functions[i+1](x) + tolerance:
                    logger.warning("Sequence is not monotone increasing")
                    return False

        # Compute integrals
        sequence_integrals = [
            LebesgueIntegrator.integrate_discrete(f, measure)
            for f in sequence_functions
        ]
        limit_integral = LebesgueIntegrator.integrate_discrete(limit_function, measure)

        # Check convergence
        final_integral = sequence_integrals[-1]

        return abs(final_integral - limit_integral) < tolerance

    @staticmethod
    def verify_dominated_convergence(
        sequence_functions: List[MeasurableFunction],
        limit_function: MeasurableFunction,
        dominating_function: MeasurableFunction,
        measure: Measure,
        tolerance: float = 1e-6
    ) -> bool:
        """
        Verify Dominated Convergence Theorem.

        If |fₙ| ≤ g for integrable g and fₙ → f a.e., then:
        ∫ f dμ = lim ∫ fₙ dμ
        """
        # Check domination
        for f in sequence_functions:
            for x in measure.sigma_algebra.space:
                if abs(f(x)) > dominating_function(x) + tolerance:
                    logger.warning("Sequence is not dominated")
                    return False

        # Compute integrals
        sequence_integrals = [
            LebesgueIntegrator.integrate_discrete(f, measure)
            for f in sequence_functions
        ]
        limit_integral = LebesgueIntegrator.integrate_discrete(limit_function, measure)

        # Check convergence
        final_integral = sequence_integrals[-1]

        return abs(final_integral - limit_integral) < tolerance


# ============================================================================
# EXPORTS
# ============================================================================

__all__ = [
    'SigmaAlgebra',
    'Measure',
    'LebesgueMeasure',
    'MeasurableFunction',
    'LebesgueIntegrator',
    'ConvergenceTheorems'
]
